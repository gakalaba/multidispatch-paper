\section{\Multidispatch{} Linearizability}
\label{sec:mdl}

In this section, we first define \multidispatch{} linearizability. 
We then show how applications built atop an \MDL{} system appear
to behave identically (as far as users can tell) to the same application interacting
with a comparable \SDL{} system. Finally, we discuss existing implementations
of \MDL{} for single-shard systems and why they do not trivially extend to more
shards. 

\subsection{Preliminaries}
\label{sec:mdl:preliminaries}

In this section, we provide a precise definition of \multidispatch{} linearizability.
We extend the formalism used by Herlihy et al.~\cite{herlihy1990linearizability}.

We model an \textit{application} as a collection of \textit{processes}. Application
processes interact with shared \textit{systems} (e.g., a key-value store). Each system
has a unique \textit{name} and a \textit{type}. The latter defines the system's possible
\textit{states} as well as the \textit{operations} processes can use to interact with it.

A \textit{history} $H$ is a sequence of operation \textit{invocations} and \textit{responses}
representing an execution of the application processes interacting with the system.
We assume each operation is uniquely identifiable and is \textit{complete}, comprising
a \textit{matching} invocation-response pair, or is just a \textit{pending} invocation,
which lacks a matching response. Given a history $H$, $\complete(H)$ is the history
found by removing any incomplete operations from $H$.

A \textit{sequential history} $S$ is one comprising a sequence of matching invocation-response
pairs. A system's \textit{sequential specification} is a prefix-closed set of sequential histories
defining the system's correct behaviors in the absence of concurrency. For instance, a
key-value store's sequential specification would contain all histories such any read of key $k$
returns the value of the write to $k$ that precedes it in the history (or \texttt{null} if no
such write exists). A history is \textit{legal} if it is in the sequential specification.

A \textit{process sub-history} $H|P$ is the subsequence of all invocations and responses
in $H$ invoked or received by the application process $P$. To define \MDL{}, we relax the
assumption made by Herlihy et al.~\cite{herlihy1990linearizability} that process sub-histories
(i.e., their interactions with the system) are sequential. Instead, we say a history $H$
is \textit{well-formed} if the following hold for each process sub-history $H|P$:
(1) $H|P$ starts with an invocation, and (2) for each operation $o$, if $\res(o)$ is in $H$,
it follows (not necessarily immediately) $\inv(o)$. We consider only well-formed histories.

Given a history $H$, $H||P$ is a \textit{sequentialization} of $H|P$. $H||P$ is
found by, for each complete operation $o$ in $H|P$, shifting $\res(o)$ left (earlier) in $H|P$
until it immediately follows $\inv(o)$. Note that if $H|P$ is sequential, then $H|P = H||P$.

\subsection{\Multidispatch{} Linearizability}
\label{sec:mdl:def}

A history $H$ induces an irreflexive partial order $<_H$ on operations: $o_1 <_H o_2$ if and only if
one of the following holds: (1) $\res(o_1)$ precedes $\inv(o_2)$ in $H$, or (2) $o_1$ and $o_2$
belong to the same process and $\inv(o_1)$ precedes $\inv(o_2)$.

A history $H$ is \multidispatch{} linearizable if it can be extended, by appending one or more
responses, to some history $H^\prime$ such that:
\begin{enumerate}
    \item There exists some legal sequential history $S$ such that for all $P$,
    $\complete(H^\prime)||P = S|P$, and
    \item $<_{H^\prime} \subseteq <_S$.
\end{enumerate}

Since $H|P = H||P$ if $H|P$ is sequential, under Herlihy et al.'s original assumption
that processes are sequential, our definition matches that of
Linearizability~\cite{herlihy1990linearizability}.

\subsubsection{Suffix-Closed Failures}
\label{sec:mdl:def:failures}

There is an important implication for system designers baked into the definition above.
In systems where operations can fail (even temporarily before being retried), the effects
of an operation cannot be exposed to other processes until all of its predecessors are
guaranteed to succeed. Doing so would violate the intuitively correct behavior of most
systems, and formally, this would result in $\complete(H^\prime)||P \neq S|P$ for all legal
sequential histories $S$. We refer to this property as \textit{suffix-closed failure semantics}.

In a \multidispatch{} linearizable system, we must ensure suffix-closed failures even in the
face of concurrent operations from the same process. The challenge arises because in practice,
these operations can be to objects on different shards. As we will see in
Section~\ref{sec:mdl:zookeeper}, guaranteeing suffix-closed failures is one way in which
existing systems fail to correctly implement \multidispatch{} linearizability.  

\subsection{External Equivalence}
\label{sec:mdl:equivalence}

\subsection{\MDL{} Beyond One Shard}
\label{sec:mdl:zookeeper}

In this section, we discuss Zookeeper and its implementation of \SDL{}.
We also show how such an approach does not extend to multiple shards.

\begin{figure}[!htb]
    \includegraphics[scale=.45]{somet.png}
    \caption{Example execution where two concurrent clients each submit 2 concurrent requests. Assume keys \textbf{X} and \textbf{Y} are at different shards. It is possible that $R_2$ arrives before $W_1$ at shard \textbf{X}, and $W_2$ arrives before $R_1$ at shard \textbf{Y}. Since clients expect their concurrent requests to take affect in invocation order, if $R_1$ returns 1, then $W_1$ must have taken affect before $R_1$, so $R_2$ should necessarily return a value of 1.}
    \label{fig:concurrentbatches}
\end{figure}

For the single-shard setting, existing protocols come close to providing \MDL{}. A simple mechanism, such as per-client sequence numbers, can provide enough information for a shard leader to support invocation order for multiple requests from a single client. Such a solution does not suffice in the multi-shard setting, however, as shown in figure ~\ref{fig:concurrentbatches}. Linearizability is a local property, thus a single-shard protocol correctly scales to multiple shards. \MDL{}, however, is not a local property due to the possible interleaving of sets of concurrent requests across concurrent clients.
% Jeff: I don't think we want (or need) to make the claim below.
% This requires an \MDL{} protocol to use inter-shard communication in order to guarantee a safe total ordering that reflects issue order.

Sequence numbers are assigned at the client library 
and increase monotonically per shard. For example, a client issuing two requests for the first time to different keys that are on different shards will issue two requests both with sequence number 0. The shard leaders can then easily detect when a client's request
has arrived out of order and can buffer it until the necessary predecessor requests intended for the same shard arrive.
